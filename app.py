import os
import subprocess
import time
import shutil
import uuid
import zipfile
import webbrowser

import requests
from flask import Flask, request, jsonify, send_file, render_template

from modules.voice import speech_to_text
from modules.voice import text_to_speech

from modules.models import chatgpt
# from modules.models import edgegpt
# from modules.models import pygmalion


def ffmpeg_check() -> None:
    """
    The function checks if FFmpeg is installed on the system.
    :return: The function `ffmpeg_check()` returns a boolean value. It returns `True` if the `ffmpeg`
    command is found and can be executed, and `False` if the command is not found.
    """
    try:
        subprocess.run('ffmpeg', creationflags=0x08000000)
        return True
    except FileNotFoundError:
        return False


def download_ffmpeg() -> None:
    """
    This function downloads and extracts the latest version of ffmpeg for Windows and copies the
    necessary file then deleting temporary files.
    """
    print('ffmpeg not found, downloading...')
    # download ffmpeg zip
    url = 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'
    r = requests.get(url, allow_redirects=True)
    open('./ffmpeg.zip', 'wb').write(r.content)
    print('downloaded, extracting...')

    # extract / unzip
    with zipfile.ZipFile('./ffmpeg.zip', 'r') as zip_ref:
        zip_ref.extractall('./ffmpeg')
    print('extracted, copying necessary files...')

    # copy necessary file
    for folder in os.listdir('./ffmpeg'):
        shutil.copyfile(f'./ffmpeg/{folder}/bin/ffmpeg.exe', './ffmpeg.exe')
        break
    print('copied, waiting 5 secs before delete temporary files...')
    time.sleep(5)

    # delete temporary files
    try:
        shutil.rmtree('./ffmpeg')
        os.unlink('./ffmpeg.zip')
    except PermissionError:
        print("encouter permisison error when trying to delete temporary files, you may want to manually delete 'ffmpeg.zip' and 'ffmpeg' folder later")


def delete_files(path: str) -> None:
    """
    This function deletes all files in a given directory path.

    :param path: The path parameter is a string that represents the directory path where the files need
    to be deleted
    :type path: str
    """
    for filename in os.listdir(path):
        file_path = os.path.join(path, filename)
        try:
            if os.path.isfile(file_path):
                os.unlink(file_path)
        except Exception as e:
            print(f'Failed to delete {file_path}. Reason: {e}')


app = Flask(__name__)


@app.route('/')
def index():
    """
    The function "index" returns the rendered template of "index.html".
    :return: The function `index()` is returning the result of calling the `render_template()` function
    with the argument `'index.html'`. The specific result depends on the implementation of the
    `render_template()` function, but typically it would be an HTML page that is rendered and displayed
    in the user's web browser.
    """
    return render_template('index.html')


@app.route('/stt', methods=['POST'])
def stt():
    """
    This function takes an audio file, saves it to a specified path, transcribes the audio to text using
    a speech-to-text API, and returns the text.
    :return: a JSON object containing the transcribed text from an audio file uploaded through a web
    request. If there is no file found in the request, it returns a string "No file found" with a status
    code of 400.
    """
    if 'file' not in request.files:
        return 'No file found', 400

    # save voice file from front
    file = request.files['file']
    recording_path = f"./uploads/{uuid.uuid4()}.wav"
    os.makedirs(os.path.dirname(recording_path), exist_ok=True)
    file.save(recording_path)

    text = speech_to_text.stt_from_file(recording_path)
    delete_files('./uploads')  # delete downloaded file after stt
    return jsonify({'text': text})


@app.route('/prompt', methods=['POST'])
def prompt():
    """
    This function takes a conversation as input, generates a reply using chatgpt, converts the reply to
    an audio file using text_to_speech, and returns the reply text and audio file path.
    :return: The function `prompt()` returns a JSON object containing the text reply generated by the
    `chatgpt()` function and the path to the corresponding audio file.
    """
    delete_files('./outputs')  # delete previous outputs

    # get reply from language model
    conversation = request.get_json(force=True).get("conversation", "")
    reply = chatgpt.run(conversation.pop()['content'])

    # save tts file
    reply_file = f"{uuid.uuid4()}.mp3"
    reply_path = f"./outputs/{reply_file}"
    os.makedirs(os.path.dirname(reply_path), exist_ok=True)
    text_to_speech.tts(reply, reply_path)

    return jsonify({'text': reply, 'audio': f"/listen/{reply_file}"})


@app.route('/listen/<filename>')
def listen(filename):
    """
    The function "listen" returns an audio file with the specified filename in the "outputs" directory
    as an mp3 file.

    :param filename: The name of the file that will be sent to the user for listening. The file should
    be located in the "outputs" directory. The function will return the file with the specified filename
    in the MP3 audio format. The "as_attachment" parameter is set to False, which means that the file
    :return: the audio file with the specified filename from the "outputs" directory, with the mimetype
    set to "audio/mp3" and the as_attachment parameter set to False.
    """
    return send_file(f"./outputs/{filename}", mimetype="audio/mp3", as_attachment=False)


if __name__ == '__main__':
    if ffmpeg_check() is False:
        download_ffmpeg()
    webbrowser.open('http://127.0.0.1:3000')
    app.run(port=3000)
